import {
  useOrderTableColumns
} from "./chunk-ET7DOC2X.mjs";
import {
  useOrderTableQuery
} from "./chunk-XMAWMECC.mjs";
import "./chunk-SJ3E4T6B.mjs";
import "./chunk-CB22IFJF.mjs";
import "./chunk-7DXVXBSA.mjs";
import {
  getStylizedAmount
} from "./chunk-OSOI7J6Y.mjs";
import "./chunk-ADOCJB6L.mjs";
import "./chunk-P3UUX2T6.mjs";
import {
  _DataTable,
  useDataTable
} from "./chunk-7VJK6HNE.mjs";
import "./chunk-YEDAFXMB.mjs";
import "./chunk-AOFGTNG6.mjs";
import "./chunk-EMIHDNB7.mjs";
import "./chunk-Y2RYZS5B.mjs";
import "./chunk-Z26G6WFJ.mjs";
import "./chunk-M3VFKDXJ.mjs";
import {
  SingleColumnPage
} from "./chunk-2RQLKDBF.mjs";
import {
  useDataTableDateFilters
} from "./chunk-Q33G337Z.mjs";
import {
  DataTable,
  SaveViewDialog,
  useViewConfiguration,
  useViewConfigurations
} from "./chunk-ONULGYMV.mjs";
import {
  useQueryParams
} from "./chunk-C76H5USB.mjs";
import "./chunk-PFKKVLZX.mjs";
import {
  getCountryByIso2
} from "./chunk-DG7J63J2.mjs";
import {
  useFeatureFlag
} from "./chunk-RM6NY572.mjs";
import {
  useExtension
} from "./chunk-C5P5PL3E.mjs";
import "./chunk-LPEUYMRK.mjs";
import "./chunk-3NJTXRIY.mjs";
import "./chunk-OC7BQLYI.mjs";
import "./chunk-67ORSRVT.mjs";
import {
  useOrders
} from "./chunk-KSRI5LOF.mjs";
import "./chunk-YI4CZGTU.mjs";
import {
  useEntityColumns
} from "./chunk-L4JIBR6K.mjs";
import {
  useSalesChannels
} from "./chunk-4Q4LIFFO.mjs";
import {
  useRegions
} from "./chunk-QZ6PT4QV.mjs";
import "./chunk-QL4XKIVL.mjs";
import "./chunk-X4X5KUGQ.mjs";
import "./chunk-FXYH54JP.mjs";
import "./chunk-774WSTCC.mjs";
import "./chunk-DEQUVHHE.mjs";
import "./chunk-RPUOO7AV.mjs";

// src/routes/orders/order-list/components/order-list-table/order-list-table.tsx
import { Container as Container2, Heading } from "@medusajs/ui";
import { keepPreviousData as keepPreviousData2 } from "@tanstack/react-query";
import { useTranslation as useTranslation3 } from "react-i18next";

// src/routes/orders/order-list/components/order-list-table/use-order-table-filters.tsx
import { useMemo } from "react";
import { useTranslation } from "react-i18next";
import { createDataTableFilterHelper } from "@medusajs/ui";
var filterHelper = createDataTableFilterHelper();
var useOrderTableFilters = () => {
  const { t } = useTranslation();
  const dateFilters = useDataTableDateFilters();
  const { regions } = useRegions({
    limit: 1e3,
    fields: "id,name"
  });
  const { sales_channels } = useSalesChannels({
    limit: 1e3,
    fields: "id,name"
  });
  return useMemo(() => {
    const filters = [...dateFilters];
    if (regions?.length) {
      filters.push(
        filterHelper.accessor("region_id", {
          label: t("fields.region"),
          type: "multiselect",
          options: regions.map((r) => ({
            label: r.name,
            value: r.id
          }))
        })
      );
    }
    if (sales_channels?.length) {
      filters.push(
        filterHelper.accessor("sales_channel_id", {
          label: t("fields.salesChannel"),
          type: "multiselect",
          options: sales_channels.map((s) => ({
            label: s.name,
            value: s.id
          }))
        })
      );
    }
    return filters;
  }, [regions, sales_channels, dateFilters, t]);
};

// src/routes/orders/order-list/components/order-list-table/configurable-order-list-table.tsx
import { useState as useState2, useMemo as useMemo5, useCallback as useCallback2, useEffect as useEffect2 } from "react";
import { Container, Button as Button2 } from "@medusajs/ui";
import { keepPreviousData } from "@tanstack/react-query";
import { useTranslation as useTranslation2 } from "react-i18next";
import { useSearchParams } from "react-router-dom";

// src/hooks/table/columns/use-configurable-order-table-columns.tsx
import React, { useMemo as useMemo2 } from "react";
import { createDataTableColumnHelper } from "@medusajs/ui";

// src/lib/table-display-utils.tsx
import { Badge, StatusBadge, Tooltip } from "@medusajs/ui";
import ReactCountryFlag from "react-country-flag";
import { jsx } from "react/jsx-runtime";
var getNestedValue = (obj, path) => {
  return path.split(".").reduce((current, key) => current?.[key], obj);
};
var formatDate = (date, format = "short") => {
  const dateObj = new Date(date);
  switch (format) {
    case "short":
      return dateObj.toLocaleDateString("en-GB", {
        day: "numeric",
        month: "short",
        year: "numeric"
      });
    case "long":
      return dateObj.toLocaleDateString("en-GB", {
        day: "numeric",
        month: "long",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    case "relative":
      const now = /* @__PURE__ */ new Date();
      const diffInMs = now.getTime() - dateObj.getTime();
      const diffInDays = Math.floor(diffInMs / (1e3 * 60 * 60 * 24));
      if (diffInDays === 0)
        return "Today";
      if (diffInDays === 1)
        return "Yesterday";
      if (diffInDays < 7)
        return `${diffInDays} days ago`;
      return dateObj.toLocaleDateString("en-GB", {
        day: "numeric",
        month: "short"
      });
    default:
      return dateObj.toLocaleDateString();
  }
};
var PaymentStatusBadge = ({ status }) => {
  const getStatusColor = (status2) => {
    switch (status2?.toLowerCase()) {
      case "paid":
      case "captured":
        return "green";
      case "pending":
      case "awaiting":
        return "orange";
      case "failed":
      case "canceled":
        return "red";
      default:
        return "grey";
    }
  };
  return /* @__PURE__ */ jsx(StatusBadge, { color: getStatusColor(status), children: status });
};
var FulfillmentStatusBadge = ({ status }) => {
  const getStatusColor = (status2) => {
    switch (status2?.toLowerCase()) {
      case "fulfilled":
      case "shipped":
        return "green";
      case "partially_fulfilled":
      case "preparing":
        return "orange";
      case "canceled":
      case "returned":
        return "red";
      case "pending":
      case "not_fulfilled":
        return "grey";
      default:
        return "grey";
    }
  };
  return /* @__PURE__ */ jsx(StatusBadge, { color: getStatusColor(status), children: status });
};
var GenericStatusBadge = ({ status }) => {
  return /* @__PURE__ */ jsx(Badge, { variant: "outline", className: "capitalize", children: status });
};
var DISPLAY_STRATEGIES = {
  // Known semantic types with pixel-perfect display
  status: {
    payment: (value) => /* @__PURE__ */ jsx(PaymentStatusBadge, { status: value }),
    fulfillment: (value) => /* @__PURE__ */ jsx(FulfillmentStatusBadge, { status: value }),
    default: (value) => /* @__PURE__ */ jsx(GenericStatusBadge, { status: value })
  },
  currency: {
    default: (value, row) => {
      if (value === null || value === void 0)
        return "-";
      const currencyCode = row.currency_code || "USD";
      const formatted = getStylizedAmount(value, currencyCode);
      return /* @__PURE__ */ jsx("div", { className: "flex h-full w-full items-center justify-end text-right", children: /* @__PURE__ */ jsx("span", { className: "truncate", children: formatted }) });
    }
  },
  timestamp: {
    creation: (value) => value ? formatDate(value, "short") : "-",
    update: (value) => value ? formatDate(value, "relative") : "-",
    default: (value) => value ? formatDate(value, "short") : "-"
  },
  identifier: {
    order: (value) => `#${value}`,
    default: (value) => value
  },
  email: {
    default: (value) => value || "-"
  },
  // Generic fallbacks for custom fields
  enum: {
    default: (value) => /* @__PURE__ */ jsx(GenericStatusBadge, { status: value })
  },
  // Base type fallbacks
  string: {
    default: (value) => value || "-"
  },
  number: {
    default: (value) => value?.toLocaleString() || "0"
  },
  boolean: {
    default: (value) => /* @__PURE__ */ jsx(Badge, { variant: value ? "solid" : "outline", children: value ? "Yes" : "No" })
  },
  object: {
    relationship: (value) => {
      if (!value || typeof value !== "object")
        return "-";
      if (value.name)
        return value.name;
      if (value.title)
        return value.title;
      if (value.email)
        return value.email;
      if (value.display_name)
        return value.display_name;
      return JSON.stringify(value);
    },
    default: (value) => {
      if (!value || typeof value !== "object")
        return "-";
      if (value.name)
        return value.name;
      if (value.title)
        return value.title;
      if (value.email)
        return value.email;
      return JSON.stringify(value);
    }
  },
  // Date types (in addition to timestamp)
  date: {
    default: (value) => value ? formatDate(value, "short") : "-"
  },
  datetime: {
    default: (value) => value ? formatDate(value, "long") : "-"
  },
  // Computed columns
  computed: {
    display: (value) => value || "-",
    default: (value) => value || "-"
  }
};
var getDisplayStrategy = (column) => {
  const semanticStrategies = DISPLAY_STRATEGIES[column.semantic_type];
  if (semanticStrategies) {
    const contextStrategy = semanticStrategies[column.context];
    if (contextStrategy)
      return contextStrategy;
    const defaultStrategy = semanticStrategies.default;
    if (defaultStrategy)
      return defaultStrategy;
  }
  const dataType = column.data_type === "text" ? "string" : column.data_type;
  const dataTypeStrategies = DISPLAY_STRATEGIES[dataType];
  if (dataTypeStrategies) {
    const defaultStrategy = dataTypeStrategies.default;
    if (defaultStrategy)
      return defaultStrategy;
  }
  return (value) => String(value || "-");
};
var COMPUTED_COLUMN_FUNCTIONS = {
  customer_name: (row) => {
    if (row.customer?.first_name || row.customer?.last_name) {
      const fullName = `${row.customer.first_name || ""} ${row.customer.last_name || ""}`.trim();
      if (fullName)
        return fullName;
    }
    if (row.customer?.email) {
      return row.customer.email;
    }
    if (row.customer?.phone) {
      return row.customer.phone;
    }
    return "Guest";
  },
  address_summary: (row, column) => {
    let address = null;
    if (column?.field === "shipping_address_display") {
      address = row.shipping_address;
    } else if (column?.field === "billing_address_display") {
      address = row.billing_address;
    } else {
      address = row.shipping_address || row.billing_address;
    }
    if (!address)
      return "-";
    const parts = [];
    if (address.address_1) {
      parts.push(address.address_1);
    }
    const locationParts = [];
    if (address.city)
      locationParts.push(address.city);
    if (address.province)
      locationParts.push(address.province);
    if (address.postal_code)
      locationParts.push(address.postal_code);
    if (locationParts.length > 0) {
      parts.push(locationParts.join(", "));
    }
    if (address.country_code) {
      parts.push(address.country_code.toUpperCase());
    }
    return parts.join(" \u2022 ") || "-";
  },
  country_code: (row) => {
    const countryCode = row.shipping_address?.country_code;
    if (!countryCode)
      return /* @__PURE__ */ jsx("div", { className: "flex w-full justify-center", children: "-" });
    const country = getCountryByIso2(countryCode);
    const displayName = country?.display_name || countryCode.toUpperCase();
    return /* @__PURE__ */ jsx("div", { className: "flex w-full items-center justify-center", children: /* @__PURE__ */ jsx(Tooltip, { content: displayName, children: /* @__PURE__ */ jsx("div", { className: "flex size-4 items-center justify-center overflow-hidden rounded-sm", children: /* @__PURE__ */ jsx(
      ReactCountryFlag,
      {
        countryCode: countryCode.toUpperCase(),
        svg: true,
        style: {
          width: "16px",
          height: "16px"
        },
        "aria-label": displayName
      }
    ) }) }) });
  }
};
var ENTITY_COLUMN_OVERRIDES = {
  orders: {
    // Override for customer column that combines multiple fields
    customer: {
      accessor: (row) => {
        const shipping = row.shipping_address;
        const customer = row.customer;
        if (shipping?.first_name || shipping?.last_name) {
          return `${shipping.first_name || ""} ${shipping.last_name || ""}`.trim();
        }
        if (customer?.first_name || customer?.last_name) {
          return `${customer.first_name || ""} ${customer.last_name || ""}`.trim();
        }
        return customer?.email || "Guest";
      }
    }
  }
};
var getEntityAccessor = (entity, fieldName, column) => {
  if (column?.computed) {
    const computationFn = COMPUTED_COLUMN_FUNCTIONS[column.computed.type];
    if (computationFn) {
      return (row) => computationFn(row, column);
    }
  }
  const entityOverrides = ENTITY_COLUMN_OVERRIDES[entity];
  if (entityOverrides) {
    const fieldOverride = entityOverrides[fieldName];
    if (fieldOverride?.accessor) {
      return fieldOverride.accessor;
    }
  }
  return (row) => getNestedValue(row, fieldName);
};

// src/routes/orders/order-list/components/order-list-table/utils/column-utils.ts
function getColumnAlignment(column) {
  if (column.semantic_type === "currency" || column.data_type === "currency") {
    return "right" /* RIGHT */;
  }
  if (column.data_type === "number" && column.context !== "identifier") {
    return "right" /* RIGHT */;
  }
  if (column.field.includes("total") || column.field.includes("amount") || column.field.includes("price")) {
    return "right" /* RIGHT */;
  }
  if (column.field === "country" || column.field.includes("country_code")) {
    return "center" /* CENTER */;
  }
  return "left" /* LEFT */;
}

// src/hooks/table/columns/use-configurable-order-table-columns.tsx
var columnHelper = createDataTableColumnHelper();
function useConfigurableOrderTableColumns(apiColumns) {
  return useMemo2(() => {
    if (!apiColumns?.length) {
      return [];
    }
    return apiColumns.map((apiColumn) => {
      const displayStrategy = getDisplayStrategy(apiColumn);
      const accessor = getEntityAccessor("orders", apiColumn.field, apiColumn);
      const headerAlign = getColumnAlignment(apiColumn);
      return columnHelper.accessor(accessor, {
        id: apiColumn.field,
        header: () => apiColumn.name,
        cell: ({ getValue, row }) => {
          const value = getValue();
          if (React.isValidElement(value)) {
            return value;
          }
          return displayStrategy(value, row.original);
        },
        meta: {
          name: apiColumn.name,
          column: apiColumn
          // Store column metadata for future use
        },
        enableHiding: apiColumn.hideable,
        enableSorting: false,
        // Disable sorting for all columns
        headerAlign
        // Pass the header alignment to the DataTable
      });
    });
  }, [apiColumns]);
}

// src/hooks/table/columns/use-column-state.ts
import { useState, useCallback, useMemo as useMemo3, useEffect, useRef } from "react";
function useColumnState(apiColumns, activeView) {
  const [visibleColumns, setVisibleColumns] = useState(
    () => {
      if (apiColumns?.length && activeView?.configuration) {
        const visibility = {};
        apiColumns.forEach((column) => {
          visibility[column.field] = activeView.configuration.visible_columns?.includes(column.field) || false;
        });
        return visibility;
      } else if (apiColumns?.length) {
        return getInitialColumnVisibility(apiColumns);
      }
      return {};
    }
  );
  const [columnOrder, setColumnOrder] = useState(() => {
    if (activeView?.configuration?.column_order) {
      return activeView.configuration.column_order;
    } else if (apiColumns?.length) {
      return getInitialColumnOrder(apiColumns);
    }
    return [];
  });
  const columnState = useMemo3(
    () => ({
      visibility: visibleColumns,
      order: columnOrder
    }),
    [visibleColumns, columnOrder]
  );
  const currentColumns = useMemo3(() => {
    const visible = Object.entries(visibleColumns).filter(([_, isVisible]) => isVisible).map(([field]) => field);
    return {
      visible,
      order: columnOrder
    };
  }, [visibleColumns, columnOrder]);
  const handleColumnVisibilityChange = useCallback(
    (visibility) => {
      setVisibleColumns(visibility);
    },
    []
  );
  const handleViewChange = useCallback(
    (view, apiColumns2) => {
      if (view?.configuration) {
        const newVisibility = {};
        apiColumns2.forEach((column) => {
          newVisibility[column.field] = view.configuration.visible_columns?.includes(column.field) || false;
        });
        setVisibleColumns(newVisibility);
        setColumnOrder(view.configuration.column_order || []);
      } else {
        setVisibleColumns(getInitialColumnVisibility(apiColumns2));
        setColumnOrder(getInitialColumnOrder(apiColumns2));
      }
    },
    []
  );
  const initializeColumns = useCallback(
    (apiColumns2) => {
      if (Object.keys(visibleColumns).length === 0) {
        setVisibleColumns(getInitialColumnVisibility(apiColumns2));
      }
      if (columnOrder.length === 0) {
        setColumnOrder(getInitialColumnOrder(apiColumns2));
      }
    },
    []
  );
  const prevActiveViewRef = useRef();
  useEffect(() => {
    if (apiColumns?.length) {
      const viewChanged = prevActiveViewRef.current?.id !== activeView?.id;
      const viewUpdated = activeView && prevActiveViewRef.current?.id === activeView.id && prevActiveViewRef.current.updated_at !== activeView.updated_at;
      if (viewChanged || viewUpdated) {
        if (activeView?.configuration) {
          const newVisibility = {};
          apiColumns.forEach((column) => {
            newVisibility[column.field] = activeView.configuration?.visible_columns?.includes(
              column.field
            ) || false;
          });
          setVisibleColumns(newVisibility);
          setColumnOrder(activeView.configuration?.column_order || []);
        } else {
          setVisibleColumns(getInitialColumnVisibility(apiColumns));
          setColumnOrder(getInitialColumnOrder(apiColumns));
        }
      }
    }
    prevActiveViewRef.current = activeView;
  }, [activeView, apiColumns]);
  return {
    visibleColumns,
    columnOrder,
    columnState,
    currentColumns,
    setVisibleColumns,
    setColumnOrder,
    handleColumnVisibilityChange,
    handleViewChange,
    initializeColumns
  };
}
var DEFAULT_COLUMN_ORDER = 500;
function getInitialColumnVisibility(apiColumns) {
  if (!apiColumns || apiColumns.length === 0) {
    return {};
  }
  const visibility = {};
  apiColumns.forEach((column) => {
    visibility[column.field] = column.default_visible ?? true;
  });
  return visibility;
}
function getInitialColumnOrder(apiColumns) {
  if (!apiColumns || apiColumns.length === 0) {
    return [];
  }
  const sortedColumns = [...apiColumns].sort((a, b) => {
    const orderA = a.default_order ?? DEFAULT_COLUMN_ORDER;
    const orderB = b.default_order ?? DEFAULT_COLUMN_ORDER;
    return orderA - orderB;
  });
  return sortedColumns.map((col) => col.field);
}

// src/routes/orders/order-list/components/order-list-table/components/save-view-dropdown.tsx
import { Button, DropdownMenu, usePrompt } from "@medusajs/ui";
import { ChevronDownMini } from "@medusajs/icons";
import { Fragment, jsx as jsx2, jsxs } from "react/jsx-runtime";
var SaveViewDropdown = ({
  isDefaultView,
  currentViewId,
  currentViewName,
  onSaveAsDefault,
  onUpdateExisting,
  onSaveAsNew
}) => {
  const prompt = usePrompt();
  const handleSaveAsDefault = async () => {
    const result = await prompt({
      title: "Update default view",
      description: "This will update the default view for all users. Are you sure?",
      confirmText: "Update for everyone",
      cancelText: "Cancel"
    });
    if (result) {
      onSaveAsDefault();
    }
  };
  const handleUpdateExisting = async () => {
    const result = await prompt({
      title: "Update view",
      description: `Are you sure you want to update "${currentViewName}"?`,
      confirmText: "Update",
      cancelText: "Cancel"
    });
    if (result) {
      onUpdateExisting();
    }
  };
  return /* @__PURE__ */ jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsx2(DropdownMenu.Trigger, { asChild: true, children: /* @__PURE__ */ jsxs(Button, { variant: "secondary", size: "small", children: [
      "Save",
      /* @__PURE__ */ jsx2(ChevronDownMini, {})
    ] }) }),
    /* @__PURE__ */ jsx2(DropdownMenu.Content, { align: "end", children: isDefaultView ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx2(DropdownMenu.Item, { onClick: handleSaveAsDefault, children: "Update default for everyone" }),
      /* @__PURE__ */ jsx2(DropdownMenu.Item, { onClick: onSaveAsNew, children: "Save as new view" })
    ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(DropdownMenu.Item, { onClick: handleUpdateExisting, children: [
        'Update "',
        currentViewName,
        '"'
      ] }),
      /* @__PURE__ */ jsx2(DropdownMenu.Item, { onClick: onSaveAsNew, children: "Save as new view" })
    ] }) })
  ] });
};

// src/routes/orders/order-list/components/order-list-table/hooks/use-required-fields.ts
import { useMemo as useMemo4 } from "react";

// src/routes/orders/order-list/const.ts
var DEFAULT_PROPERTIES = [
  "id",
  "status",
  "created_at",
  "email",
  "display_id",
  "payment_status",
  "fulfillment_status",
  "total",
  "currency_code"
];
var DEFAULT_RELATIONS = ["*customer", "*sales_channel"];
var DEFAULT_FIELDS = `${DEFAULT_PROPERTIES.join(
  ","
)},${DEFAULT_RELATIONS.join(",")}`;

// src/routes/orders/order-list/components/order-list-table/utils/field-utils.ts
function calculateRequiredFields(apiColumns, visibleColumns) {
  if (!apiColumns?.length) {
    return DEFAULT_FIELDS;
  }
  const visibleColumnObjects = apiColumns.filter((column) => {
    if (Object.keys(visibleColumns).length > 0) {
      return visibleColumns[column.field] === true;
    }
    return column.default_visible;
  });
  const requiredFieldsSet = /* @__PURE__ */ new Set();
  visibleColumnObjects.forEach((column) => {
    if (column.computed) {
      column.computed.required_fields?.forEach((field) => requiredFieldsSet.add(field));
      column.computed.optional_fields?.forEach((field) => requiredFieldsSet.add(field));
    } else if (!column.field.includes(".")) {
      requiredFieldsSet.add(column.field);
    } else {
      requiredFieldsSet.add(column.field);
    }
  });
  const allRequiredFields = Array.from(requiredFieldsSet);
  const visibleRelationshipFields = allRequiredFields.filter((field) => field.includes("."));
  const visibleDirectFields = allRequiredFields.filter((field) => !field.includes("."));
  const additionalRelationshipFields = visibleRelationshipFields.filter((field) => {
    const [relationName] = field.split(".");
    const isAlreadyCovered = DEFAULT_RELATIONS.some(
      (rel) => rel === `*${relationName}` || rel === relationName
    );
    return !isAlreadyCovered;
  });
  const additionalDirectFields = visibleDirectFields.filter((field) => {
    const isAlreadyIncluded = DEFAULT_PROPERTIES.includes(field);
    return !isAlreadyIncluded;
  });
  const additionalFields = [...additionalRelationshipFields, ...additionalDirectFields];
  if (additionalFields.length > 0) {
    return `${DEFAULT_FIELDS},${additionalFields.join(",")}`;
  }
  return DEFAULT_FIELDS;
}

// src/routes/orders/order-list/components/order-list-table/hooks/use-required-fields.ts
function useRequiredFields(apiColumns, visibleColumns) {
  return useMemo4(() => {
    return calculateRequiredFields(apiColumns, visibleColumns);
  }, [apiColumns, visibleColumns]);
}

// src/routes/orders/order-list/components/order-list-table/configurable-order-list-table.tsx
import { Fragment as Fragment2, jsx as jsx3, jsxs as jsxs2 } from "react/jsx-runtime";
var PAGE_SIZE = 20;
var QUERY_PREFIX = "o";
function parseSortingState(value) {
  return value.startsWith("-") ? { id: value.slice(1), desc: true } : { id: value, desc: false };
}
var ConfigurableOrderListTable = () => {
  const { t } = useTranslation2();
  const isViewConfigEnabled = useFeatureFlag("view_configurations");
  const {
    activeView,
    createView
  } = useViewConfigurations("orders");
  const currentActiveView = activeView?.view_configuration || null;
  const { updateView } = useViewConfiguration("orders", currentActiveView?.id || "");
  const { columns: apiColumns, isLoading: isLoadingColumns } = useEntityColumns("orders", {
    enabled: isViewConfigEnabled
  });
  const filters = useOrderTableFilters();
  const queryParams = useQueryParams(
    ["q", "order", ...filters.map((f) => f.id)],
    QUERY_PREFIX
  );
  const [_, setSearchParams] = useSearchParams();
  const {
    visibleColumns,
    columnOrder,
    currentColumns,
    setColumnOrder,
    handleColumnVisibilityChange,
    handleViewChange: originalHandleViewChange
  } = useColumnState(apiColumns, currentActiveView);
  useEffect2(() => {
    if (!apiColumns)
      return;
    originalHandleViewChange(currentActiveView, apiColumns);
    setSearchParams((prev) => {
      const keysToDelete = Array.from(prev.keys()).filter(
        (key) => key.startsWith(QUERY_PREFIX + "_") || key === QUERY_PREFIX + "_q" || key === QUERY_PREFIX + "_order"
      );
      keysToDelete.forEach((key) => prev.delete(key));
      if (currentActiveView) {
        const viewConfig = currentActiveView.configuration;
        if (viewConfig.filters) {
          Object.entries(viewConfig.filters).forEach(([key, value]) => {
            prev.set(`${QUERY_PREFIX}_${key}`, JSON.stringify(value));
          });
        }
        if (viewConfig.sorting) {
          const sortValue = viewConfig.sorting.desc ? `-${viewConfig.sorting.id}` : viewConfig.sorting.id;
          prev.set(`${QUERY_PREFIX}_order`, sortValue);
        }
        if (viewConfig.search) {
          prev.set(`${QUERY_PREFIX}_q`, viewConfig.search);
        }
      }
      return prev;
    });
  }, [currentActiveView, apiColumns]);
  const [debouncedHasConfigChanged, setDebouncedHasConfigChanged] = useState2(false);
  const hasConfigurationChanged = useMemo5(() => {
    const currentFilters = {};
    filters.forEach((filter) => {
      if (queryParams[filter.id] !== void 0) {
        currentFilters[filter.id] = JSON.parse(queryParams[filter.id] || "");
      }
    });
    const currentSorting = queryParams.order ? parseSortingState(queryParams.order) : null;
    const currentSearch = queryParams.q || "";
    const currentVisibleColumns = Object.entries(visibleColumns).filter(([_2, isVisible]) => isVisible).map(([field]) => field).sort();
    if (currentActiveView) {
      const viewFilters = currentActiveView.configuration.filters || {};
      const viewSorting = currentActiveView.configuration.sorting;
      const viewSearch = currentActiveView.configuration.search || "";
      const viewVisibleColumns = [...currentActiveView.configuration.visible_columns || []].sort();
      const viewColumnOrder = currentActiveView.configuration.column_order || [];
      const filterKeys = /* @__PURE__ */ new Set([...Object.keys(currentFilters), ...Object.keys(viewFilters)]);
      for (const key of filterKeys) {
        if (JSON.stringify(currentFilters[key]) !== JSON.stringify(viewFilters[key])) {
          return true;
        }
      }
      const normalizedCurrentSorting = currentSorting || void 0;
      const normalizedViewSorting = viewSorting || void 0;
      if (JSON.stringify(normalizedCurrentSorting) !== JSON.stringify(normalizedViewSorting)) {
        return true;
      }
      if (currentSearch !== viewSearch) {
        return true;
      }
      if (JSON.stringify(currentVisibleColumns) !== JSON.stringify(viewVisibleColumns)) {
        return true;
      }
      if (JSON.stringify(columnOrder) !== JSON.stringify(viewColumnOrder)) {
        return true;
      }
    } else {
      if (Object.keys(currentFilters).length > 0)
        return true;
      if (currentSorting !== null)
        return true;
      if (currentSearch !== "")
        return true;
      if (apiColumns) {
        const currentVisibleSet = new Set(
          Object.entries(visibleColumns).filter(([_2, isVisible]) => isVisible).map(([field]) => field)
        );
        const defaultVisibleSet = new Set(
          apiColumns.filter((col) => col.default_visible).map((col) => col.field)
        );
        if (currentVisibleSet.size !== defaultVisibleSet.size || [...currentVisibleSet].some((field) => !defaultVisibleSet.has(field))) {
          return true;
        }
        const defaultOrder = apiColumns.sort((a, b) => (a.default_order ?? 500) - (b.default_order ?? 500)).map((col) => col.field);
        if (JSON.stringify(columnOrder) !== JSON.stringify(defaultOrder)) {
          return true;
        }
      }
    }
    return false;
  }, [currentActiveView, visibleColumns, columnOrder, filters, queryParams, apiColumns]);
  useEffect2(() => {
    const timer = setTimeout(() => {
      setDebouncedHasConfigChanged(hasConfigurationChanged);
    }, 50);
    return () => clearTimeout(timer);
  }, [hasConfigurationChanged]);
  const handleClearConfiguration = useCallback2(() => {
    if (apiColumns) {
      originalHandleViewChange(currentActiveView, apiColumns);
    }
    setSearchParams((prev) => {
      const keysToDelete = Array.from(prev.keys()).filter(
        (key) => key.startsWith(QUERY_PREFIX + "_") || key === QUERY_PREFIX + "_q" || key === QUERY_PREFIX + "_order"
      );
      keysToDelete.forEach((key) => prev.delete(key));
      if (currentActiveView?.configuration) {
        const viewConfig = currentActiveView.configuration;
        if (viewConfig.filters) {
          Object.entries(viewConfig.filters).forEach(([key, value]) => {
            prev.set(`${QUERY_PREFIX}_${key}`, JSON.stringify(value));
          });
        }
        if (viewConfig.sorting) {
          const sortValue = viewConfig.sorting.desc ? `-${viewConfig.sorting.id}` : viewConfig.sorting.id;
          prev.set(`${QUERY_PREFIX}_order`, sortValue);
        }
        if (viewConfig.search) {
          prev.set(`${QUERY_PREFIX}_q`, viewConfig.search);
        }
      }
      return prev;
    });
  }, [currentActiveView, apiColumns]);
  const currentConfiguration = useMemo5(() => {
    const currentFilters = {};
    filters.forEach((filter) => {
      if (queryParams[filter.id] !== void 0) {
        currentFilters[filter.id] = JSON.parse(queryParams[filter.id] || "");
      }
    });
    return {
      filters: currentFilters,
      sorting: queryParams.order ? parseSortingState(queryParams.order) : null,
      search: queryParams.q || ""
    };
  }, [filters, queryParams]);
  const [saveDialogOpen, setSaveDialogOpen] = useState2(false);
  const [editingView, setEditingView] = useState2(null);
  const handleSaveAsDefault = async () => {
    try {
      if (currentActiveView?.is_system_default) {
        await updateView.mutateAsync({
          name: currentActiveView.name || null,
          configuration: {
            visible_columns: currentColumns.visible,
            column_order: currentColumns.order,
            filters: currentConfiguration.filters || {},
            sorting: currentConfiguration.sorting || null,
            search: currentConfiguration.search || ""
          }
        });
      } else {
        await createView.mutateAsync({
          name: "Default",
          is_system_default: true,
          set_active: true,
          configuration: {
            visible_columns: currentColumns.visible,
            column_order: currentColumns.order,
            filters: currentConfiguration.filters || {},
            sorting: currentConfiguration.sorting || null,
            search: currentConfiguration.search || ""
          }
        });
      }
    } catch (_2) {
    }
  };
  const handleUpdateExisting = async () => {
    if (!currentActiveView)
      return;
    try {
      await updateView.mutateAsync({
        name: currentActiveView.name,
        configuration: {
          visible_columns: currentColumns.visible,
          column_order: currentColumns.order,
          filters: currentConfiguration.filters || {},
          sorting: currentConfiguration.sorting || null,
          search: currentConfiguration.search || ""
        }
      });
    } catch (_2) {
    }
  };
  const handleSaveAsNew = () => {
    setSaveDialogOpen(true);
    setEditingView(null);
  };
  const requiredFields = useRequiredFields(apiColumns, visibleColumns);
  const filterBarContent = debouncedHasConfigChanged ? /* @__PURE__ */ jsxs2(Fragment2, { children: [
    /* @__PURE__ */ jsx3(
      Button2,
      {
        variant: "secondary",
        size: "small",
        type: "button",
        onClick: handleClearConfiguration,
        children: t("actions.clear")
      }
    ),
    /* @__PURE__ */ jsx3(
      SaveViewDropdown,
      {
        isDefaultView: currentActiveView?.is_system_default || !currentActiveView,
        currentViewId: currentActiveView?.id,
        currentViewName: currentActiveView?.name,
        onSaveAsDefault: handleSaveAsDefault,
        onUpdateExisting: handleUpdateExisting,
        onSaveAsNew: handleSaveAsNew
      }
    )
  ] }) : null;
  const { searchParams } = useOrderTableQuery({
    pageSize: PAGE_SIZE,
    prefix: QUERY_PREFIX
  });
  const { orders, count, isError, error, isLoading } = useOrders(
    {
      fields: requiredFields,
      ...searchParams
    },
    {
      placeholderData: keepPreviousData
    }
  );
  const columns = useConfigurableOrderTableColumns(apiColumns);
  if (isError) {
    throw error;
  }
  return /* @__PURE__ */ jsxs2(Container, { className: "divide-y p-0", children: [
    /* @__PURE__ */ jsx3(
      DataTable,
      {
        data: orders ?? [],
        columns,
        filters,
        getRowId: (row) => row.id,
        rowCount: count,
        enablePagination: true,
        enableSearch: true,
        pageSize: PAGE_SIZE,
        isLoading: isLoading || isLoadingColumns,
        layout: "fill",
        heading: t("orders.domain"),
        enableColumnVisibility: isViewConfigEnabled,
        initialColumnVisibility: visibleColumns,
        onColumnVisibilityChange: handleColumnVisibilityChange,
        columnOrder,
        onColumnOrderChange: setColumnOrder,
        enableViewSelector: isViewConfigEnabled,
        entity: "orders",
        currentColumns,
        filterBarContent,
        rowHref: (row) => `/orders/${row.id}`,
        emptyState: {
          empty: {
            heading: t("orders.list.noRecordsMessage")
          }
        },
        prefix: QUERY_PREFIX
      }
    ),
    saveDialogOpen && /* @__PURE__ */ jsx3(
      SaveViewDialog,
      {
        entity: "orders",
        currentColumns,
        currentConfiguration,
        editingView,
        onClose: () => {
          setSaveDialogOpen(false);
          setEditingView(null);
        },
        onSaved: () => {
          setSaveDialogOpen(false);
          setEditingView(null);
        }
      }
    )
  ] });
};

// src/routes/orders/order-list/components/order-list-table/order-list-table.tsx
import { jsx as jsx4, jsxs as jsxs3 } from "react/jsx-runtime";
var PAGE_SIZE2 = 20;
var OrderListTable = () => {
  const { t } = useTranslation3();
  const isViewConfigEnabled = useFeatureFlag("view_configurations");
  if (isViewConfigEnabled) {
    return /* @__PURE__ */ jsx4(ConfigurableOrderListTable, {});
  }
  const { searchParams, raw } = useOrderTableQuery({
    pageSize: PAGE_SIZE2
  });
  const { orders, count, isError, error, isLoading } = useOrders(
    {
      fields: DEFAULT_FIELDS,
      ...searchParams
    },
    {
      placeholderData: keepPreviousData2
    }
  );
  const filters = useOrderTableFilters();
  const columns = useOrderTableColumns({});
  const { table } = useDataTable({
    data: orders ?? [],
    columns,
    enablePagination: true,
    count,
    pageSize: PAGE_SIZE2
  });
  if (isError) {
    throw error;
  }
  return /* @__PURE__ */ jsxs3(Container2, { className: "divide-y p-0", children: [
    /* @__PURE__ */ jsx4("div", { className: "flex items-center justify-between px-6 py-4", children: /* @__PURE__ */ jsx4(Heading, { children: t("orders.domain") }) }),
    /* @__PURE__ */ jsx4(
      _DataTable,
      {
        columns,
        table,
        pagination: true,
        navigateTo: (row) => `/orders/${row.original.id}`,
        filters,
        count,
        search: true,
        isLoading,
        pageSize: PAGE_SIZE2,
        orderBy: [
          { key: "display_id", label: t("orders.fields.displayId") },
          { key: "created_at", label: t("fields.createdAt") },
          { key: "updated_at", label: t("fields.updatedAt") }
        ],
        queryObject: raw,
        noRecords: {
          message: t("orders.list.noRecordsMessage")
        }
      }
    )
  ] });
};

// src/routes/orders/order-list/order-list.tsx
import { jsx as jsx5 } from "react/jsx-runtime";
var OrderList = () => {
  const { getWidgets } = useExtension();
  return /* @__PURE__ */ jsx5(
    SingleColumnPage,
    {
      widgets: {
        after: getWidgets("order.list.after"),
        before: getWidgets("order.list.before")
      },
      hasOutlet: false,
      children: /* @__PURE__ */ jsx5(OrderListTable, {})
    }
  );
};
export {
  OrderList as Component
};
